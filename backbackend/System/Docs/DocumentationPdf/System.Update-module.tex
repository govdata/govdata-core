%
% API Documentation for DataEnvironment
% Module System.Update
%
% Generated by epydoc 3.0.1
% [Tue Mar 31 17:17:20 2009]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{System \textit{(package)}!System.Update \textit{(module)}|(}
\section{Module System.Update}

    \label{System:Update}
\begin{alltt}

Functions for automatic updating of data in the Data Environment by calling 
scripts indicated by data dependency links. 
        
The basic flow of information is that the functions in this module are 
fed by data produced by the functions from the module 
System.LinkManagement module.  Specifically, LinkManagement functions
(like GetLinksBelow) generate sequences of data dependency links 
representing progations up or downward in the directed acyclic graph
formed by the set of all Data Dependency links.  These functions 
can be passed parameters that have them qualify the links they return 
by timestamps to show only those links that actually \_need\_ updating, 
or be unqualified and actually show the full down- or upstream propagations. 

The data dependency link sequences come in the following form:

        [L1, L2, L3 ... , LN]

where each LI is (essentially) a numpy record array of dependency 
links meant to be called at stage i of an update -- because things at 
stage i-1 are input dependencies to things at stage i, which are in turn 
inputs to things at stage i + 1.   Within the LI, the records links 
represented (essentially) as:

        (Source,Target,Script)

where "Script" is the procedure that needs to be called to produce
Target from Source. 

Once the sequences of links are returned to functions here, the 
UpdateLInks function calls the scripts indicated by these links,
in the rounds indicated by the sequence. 

There are two basic approaches to automatic updating that are 
supported by the routines provided here.

1) "Downstream Updating," in which the user asks the system to detect 
changes have been made, either to data or scripts, since an update was 
last run, and then propagate the results of these changes downstream 
through the data dependency graph.  This functionality is implemented
by the "FullUpdate" function. 
        
2) "Upstream Updating," in which the user specifies a target or set of
targets that he wishes to remake; then the system determines which 
upstream elements have been modified since the last creation of the 
target, and runs those that need updating in the proper order.  This 
functionality -- which is similar in spirit to the traditional "makefile" 
commands available for many code-compilation schemes -- is
implemented by the "MakeUpdated" function. 

The "FindOutWhatWillUpdate" function displays what scripts will be 
called, given various options to the updater, without actually calling
any updates. 

The user can blend the two updating styles along a seemless
continuum.  The is done is via Automatic Updates filtering.  The 
user specifies in a configuration file (whose path is set at the 
AutomaticUpdatesPath environment variable) those scripts or 
script-name patterns that should or should not be updated upon
downstream propation.  Then, when calling a MakeUpdated command
to a set of targets, Upstream changes are included, as well as 
downstream propagations from those upstream changes that are 
allowed by the Automatic Updates settings.   

The advantage of Downstream Updating is that it does not require 
the user to think about the implications of the changes he's making: 
he merely makes changes to data and scripts, and then calls FullUpdate,
regardless of what the changes were; he does not have to remember 
which files the changes are bound to affect and then make sure 
those are updated.  On the other hand, this style of updating means 
that the user ends up having to modify the "Automatic Updates" 
settings occasionally to prevent unwanted updates from occuring, 
as well to enable wanted updates to actual happen.  It also means 
that he often will want to call "FindOutWhatWillUpdate" before 
"FullUpdate" to make see ahead of time to see which unwated
automatic updates (if any) he may have to disable.    Downstream
Update "purists" will typically want to set the "Automatic Updates"
file to enable updating of most of what they're working on at any
given period, and then only call the two commands "FindOutWhatWillUpdate"
and "FullUpdate" repeatedly. 

The Upstream style has the advantage of being more targeted -- and 
requiring no interaction (if not wanted) with the automatic update 
settings.   The Upstream Update "purists" -- those for example who 
may be familiar with the idea of Makefiles and want to use that style
in the data analysis work -- will typically want to set the Automatic 
Updates setting to contain little or nothing, and then call 
MakeUpdated(Target) for whatever end-point target they ultimately 
want to keep updated. 

In either case, the user can \_force\_ updating by setting the Force options
to True (this is like the "make clean" option in make systems); or have
the system update just those things that the system thinks really need 
updating.   
\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{System:Update:MakeUpdated}
    \index{System \textit{(package)}!System.Update \textit{(module)}!System.Update.MakeUpdated \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{MakeUpdated}(\textit{Targets}, \textit{depends\_on}={\tt ('../',)}, \textit{creates}={\tt ('../Data/',)}, \textit{Simple}={\tt True}, \textit{Forced}={\tt False}, \textit{Pruning}={\tt True}, \textit{ProtectComputed}={\tt False}, \textit{EmailWhenDone}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Implements the upstream updating style 

ARGUMENTS:
--Targets = List of targets to update upstream from
--Simple = if true, look for changes just at the top level of declared 
        dependencies (e.g. modifitions to the directories named in the
        dependency lists);  otherwise, look for changes below (in the 
        file-system sense of "below") these top-level dependency path names     
--Forced = rebuild the entire upstream tree, regardless of what 
        appears to be need rebuilding to handle changes. 
--ProtectComputed = rebuilding downstream things that appear to 
        have changed since their last official build and therefore (might be)
        corrupted.
--EmailWhenDone = email address to send report of system update to,
        upon completion (including error reports of scripts that fail)
        
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Update:FullUpdate}
    \index{System \textit{(package)}!System.Update \textit{(module)}!System.Update.FullUpdate \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FullUpdate}(\textit{Seed}={\tt ['../']}, \textit{Exceptions}={\tt None}, \textit{Simple}={\tt True}, \textit{Forced}={\tt False}, \textit{Pruning}={\tt True}, \textit{ProtectComputed}={\tt False}, \textit{EmailWhenDone}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Implements the downstream updating style.

ARGUMENTS:
--Seed = set of initial targets to go downstream from.  
--Simple = if true, look for changes just at the top level of declared 
        dependencies (e.g. modifitions to the directories named in the
        dependency lists);  otherwise, look for changes below (in the
        file-system sense of "below") these top-level dependency path names
--Forced = rebuild the entire upstream tree, regardless of what appears 
        to be need rebuilding to handle changes. 
--ProtectComputed = rebuilding downstream things that appear to 
        have changed since their last official build and therefore 
        might be corrupted.
--EmailWhenDone = email address to send report of system update to,
        upon completion (including error reports of scripts that fail)
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Update:FindOutWhatWillUpdate}
    \index{System \textit{(package)}!System.Update \textit{(module)}!System.Update.FindOutWhatWillUpdate \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FindOutWhatWillUpdate}(\textit{Seed}={\tt ['../']}, \textit{Exceptions}={\tt None}, \textit{Simple}={\tt True}, \textit{Forced}={\tt False}, \textit{Pruning}={\tt True}, \textit{ProtectComputed}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Determine and print out readable report indicating which files 
downstream of a seed will update (without making the actual update). 

ARGUMENTS:
--Seed = set of initial targets to go downstream from.  
--Simple = if true, look for changes just at the top level 
        of declared dependencies (e.g. modifitions to the directories named
        in the dependency lists);  otherwise, look for changes below (in 
        the file-system sense of "below") these top-level dependency path names
--Forced = act as if rebuilding the entire upstream tree, regardless of what 
        appears to be need rebuilding to handle changes. 
--ProtectComputed = include downstream things that appear to have 
        changed since their last official build and therefore might be corrupted.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Update:LinkUpdate}
    \index{System \textit{(package)}!System.Update \textit{(module)}!System.Update.LinkUpdate \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{LinkUpdate}(\textit{Seed}, \textit{Exceptions}={\tt None}, \textit{depends\_on}={\tt ('../',)}, \textit{creates}={\tt ('../Data/',)}, \textit{Simple}={\tt False}, \textit{Forced}={\tt False}, \textit{Pruning}={\tt True}, \textit{ProtectComputed}={\tt False}, \textit{EmailWhenDone}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Given a seed and some options, call GetLinksBelow routine from LinkManagement, 
and feed the result of that to the automatic updater. 

This function is not usually called directly, but is called with arguments 
set by either MakeUpdated or FullUpdate. 

ARGUMENTS:
--Seed = set of initial targets to go downstream from.  
--Simple = if true, look for changes just at the top level of declared 
        dependencies (e.g. modifitions to the directories named in the 
        dependency lists);  otherwise, look for changes below (in the file-system 
        sense of "below") these top-level dependency path names
--Forced = act as if rebuilding the entire upstream tree, regardless of what appears 
        to be need rebuilding to handle changes. 
--ProtectComputed = include downstream things that appear to have changed 
since their last official build and therefore (might be) corrupted.             
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Update:UpdateLinks}
    \index{System \textit{(package)}!System.Update \textit{(module)}!System.Update.UpdateLinks \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{UpdateLinks}(\textit{ActivatedLinkListSequence}, \textit{Seed}, \textit{Exceptions}={\tt None}, \textit{Simple}={\tt None}, \textit{Pruning}={\tt None}, \textit{Forced}={\tt None}, \textit{ProtectComputed}={\tt False}, \textit{depends\_on}={\tt ('../',)}, \textit{creates}={\tt ('../',)}, \textit{EmailWhenDone}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}
This function is the main driver of automatic updating in the system.  It takes in a
sequence of sets of links, and applies the scripts indicated by those links in the 
proper order.  If possible, it saves previous outputs of these scripts in a safe 
place so that if a script fails, the previous output can be reverted to.  It 
keeps track of success or failure along the way, and if failure occurs,
downstream updates are cancelled.   It also has a built-in diff-checker, 
so that if outputs of a given script are not different from previous runs, 
downstream files are merely touched (i.e., have their timestamps updated) 
but not recomputed.  

This function is not usually called directly by the user, but instead with its 
arguments et by LinkUpdate. 

Arguments:
--ActivatedLinkListSequence -- a sequence of recarrays of 
        links (as produced, e.g. by GetLinksBelow).  
--Seed:  the original files updates to which set off the linklist activation.  
        This is used for recomputing when failure or no difference occurs. 
                        
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Update:printscriptrounds}
    \index{System \textit{(package)}!System.Update \textit{(module)}!System.Update.printscriptrounds \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{printscriptrounds}(\textit{ScriptsToCall})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright n\-a\-n\- & \raggedright \textbf{Value:} 
{\tt numpy.nan}&\\
\cline{1-2}
\end{longtable}

    \index{System \textit{(package)}!System.Update \textit{(module)}|)}
