%
% API Documentation for DataEnvironment
% Module System.Protocols
%
% Generated by epydoc 3.0.1
% [Tue Mar 31 17:17:20 2009]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{System \textit{(package)}!System.Protocols \textit{(module)}|(}
\section{Module System.Protocols}

    \label{System:Protocols}
Functions for implementing data protocols.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{System:Protocols:ApplyOperations}
    \index{System \textit{(package)}!System.Protocols \textit{(module)}!System.Protocols.ApplyOperations \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ApplyOperations}(\textit{outfilename}, \textit{OpThing})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    This is deprecated and only kept around to support a couple of initial 
    protocols built using it.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Protocols:ApplyOperations2}
    \index{System \textit{(package)}!System.Protocols \textit{(module)}!System.Protocols.ApplyOperations2 \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ApplyOperations2}(\textit{outfilename}, \textit{OpThing}, \textit{WriteMetaData}={\tt True})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Function which implements the basic protocol concept.  
Given an 'OpThing', which is a set of descriptions of operations 
and corresponding arguments to be passed to the operations, 
this writes out a python module with functions making the calls.

ARGUMENTS:
outfilename = pathname for the output python module, must end with .py
OpThing = dictionary or list.  
1) if dictionary, then:
-- the keys are strings representing names for the concrete operations in the
        written-out python file 
-- for each key, say 'FName' the value is a 3-tuple: (function, internal arguments,  external arguments)
        where:
--function is the function -- the actual python function object, NOT the just the
        function name -- to be called as the body of FName
                                
--internal arguments are values for the arguments to be pased to FName
The internal arguments can be given in one of several forms:
        --a tuple of positional arguments
        --a dictionary of keyword arguments
        --a 2-element list [t,d] where t is a tuple 
        of positional arguments and d is a
        dictionary of keyword arguments

--external arguments is a dictionary where:
        the keys are names of keyword arguments for FName
        the values are the default values for the keyword arguments
                                        
2) if a list then:
        each element of the list is a 4-tuple
        
        (FName, function, internal arguments, external arguments)
        
        where all these are as described just above.  
        The only difference between the list-frmat input and 
        the dictionary format input is that the list format
        takes the keys of th dictionary and makes the
        first element of the tuples in the list 
        (which are now 4-tuples, as opposed to 3-tuples in 
        the dictionary case). 
        
        The reason for the list format is that it the operations 
        are written out to the file in the order specified in the list,
        whereas with a dictionary the order is  determined by the 
        order of writing out the keys of the dictionary, which is
        often not the "natural" ordering. 

WriteMetaData: boolean, which if true has the operations write 
metadata for th operations in the outputted module.
        
RETURNS:
        NOTHING
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Protocols:OpListUniqify}
    \index{System \textit{(package)}!System.Protocols \textit{(module)}!System.Protocols.OpListUniqify \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{OpListUniqify}(\textit{OpList})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    When the OpList in the ApplyOperations2 contains multiple functions 
    that are the same, e.g. have the same contents, but perhaps not the 
    same FName,this optimizes and retains only one of each.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{System \textit{(package)}!System.Protocols \textit{(module)}|)}
