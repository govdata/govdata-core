%
% API Documentation for DataEnvironment
% Module System.Utils
%
% Generated by epydoc 3.0.1
% [Tue Mar 31 17:17:20 2009]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{System \textit{(package)}!System.Utils \textit{(module)}|(}
\section{Module System.Utils}

    \label{System:Utils}
Miscellaneous utilities.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{System:Utils:TypeInfer}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.TypeInfer \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{TypeInfer}(\textit{column})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Take a list of strings, and attempt to infer a datatype that fits them 
    all. If the strings are all integers, returns a list of corresponding 
    Python integers. If the strings are all floats, returns a list of 
    corresponding Python floats. Otherwise, returns the original list of 
    strings.

    Typically used to determine the datatype of a column read from a tab- 
    or comma-separated text file.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:PermInverse}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.PermInverse \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{PermInverse}(\textit{s})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Fast invert a numpy permutation.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:RecursiveFileList}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.RecursiveFileList \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{RecursiveFileList}(\textit{ToList}, \textit{Avoid}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Given list of top-level directories, recursively gets a list of files in the directories. 

ARGUMENTS:
--ToList = list of top-level diretories as python list of path strings
--Avoid = List of regexps of directory name patterns to NOT look in 
        e..g if a directory name matches at any level, the function will not 
        look further into that directory. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:Max}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.Max \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{Max}(\textit{x})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:enumeratefrom}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.enumeratefrom \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{enumeratefrom}(\textit{i}, \textit{A})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:uniqify}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.uniqify \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{uniqify}(\textit{seq}, \textit{idfun}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Relatively fast pure python uniqification function that preservs ordering
ARGUMENTS:
        seq = sequence object to uniqify
        idfun = optional collapse function to identify items as the same
RETURNS:
        python list with first occurence of each item in seq, in order
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:FastArrayUniqify}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.FastArrayUniqify \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FastArrayUniqify}(\textit{X})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Very fast uniqify routine for numpy array 
ARGUMENT:
        X = a numpy array
RETURNS:
        [D,s] where s is a permutation that will sort X, and D is the list of "first 
        differences" in the sorted verion of X
        This can be used to produce a uniqified version of X by simply taking:
                X[s][D]
        or
                X[s[D.nonzero()[0]]]
        But sometimes the information of D and s is useful. 
                
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:FastRecarrayUniqify}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.FastRecarrayUniqify \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FastRecarrayUniqify}(\textit{X})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Record array version of FastArrayUniqify.
ARGUMENT:
        X = numpy record array
RETURNS:
        [D,s] where s is a permutation that will sort all the columsn of X in some order,
        and D is a list of "first differences" in the sorted version of X
        This can be used to produce a uniqified version of X by simply taking:
                X[s][D]
        or
                X[s[D.nonzero()[0]]]
        But sometimes the information of D and s is useful.                     
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:DirName}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.DirName \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{DirName}(\textit{path})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    utility that gets dir name;  sometimes this is the right thing to use 
    intead of os.path.dirname itself

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:open_for_read}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.open\_for\_read \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{open\_for\_read}(\textit{ToRead})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:open_for_read_universal}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.open\_for\_read\_universal \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{open\_for\_read\_universal}(\textit{ToRead})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:open_for_write}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.open\_for\_write \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{open\_for\_write}(\textit{ToWrite})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:open_for_append}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.open\_for\_append \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{open\_for\_append}(\textit{ToAddTo})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:compile_expr}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.compile\_expr \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{compile\_expr}(\textit{expr})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return a code object for the given expression.  Shorthand for compile( 
    expr, 'this\_filename', 'eval' ).

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:chkExists}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.chkExists \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{chkExists}(\textit{path})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    If the given file or directory does not exist, raise an exception

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:PathCompress}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.PathCompress \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{PathCompress}(\textit{path})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:redirect}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.redirect \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{redirect}(\textit{x}, \textit{To})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

utility that 'redirects' a path name from to a different directory. 
ARGUMENTS:
        x = path to redirect
        To = location to redirect x to
RETURNS:
        path created by taking file component of x and appending to To
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:ListArrayTranspose}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.ListArrayTranspose \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ListArrayTranspose}(\textit{L})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Tranposes the simple array presentation of a list of lists (of equal length). 
Argument:
        L = [row1, row2, ...., rowN]
        where the rowi are python lists of equal length. 
Returns:        
        LT, a list of python lists such that LT[j][i] = L[i][j]. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:GetFunctionsDefinedInModule}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.GetFunctionsDefinedInModule \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetFunctionsDefinedInModule}(\textit{Module})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given live module, use inspect module to capture list of functions in 
    module whose definition attribute is equal to the module name.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:GetFunctionsMentionedInModule}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.GetFunctionsMentionedInModule \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetFunctionsMentionedInModule}(\textit{Module})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given live module, use inspect module to capture list of functions that
    appear somewhere live in the module (e.g. are loaded when the module is
    imported)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:RedirectList}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.RedirectList \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{RedirectList}(\textit{ToRedirect}, \textit{To})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:FixedPath}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.FixedPath \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FixedPath}(\textit{path})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Does some path compression, like os.path.normpath but proper for the 
    Data Environment (consider replacing with references to 
    os.path.normpath)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:GetDataEnvironmentDirectory}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.GetDataEnvironmentDirectory \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetDataEnvironmentDirectory}()

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:PathAlong}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.PathAlong \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{PathAlong}(\textit{a}, \textit{b})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    returns true when path a is inside the filetree under path b.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:PathStrictlyAlong}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.PathStrictlyAlong \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{PathStrictlyAlong}(\textit{a}, \textit{b})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    returns true when path a is strictly insider the filetree under path b.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:funcname}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.funcname \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{funcname}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    returns name of function in call stack in which funcname() is being 
    called

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:caller}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.caller \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{caller}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    returns name of function in call stack which is calling the function 
    that  is calling caller()

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:callermodule}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.callermodule \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{callermodule}()

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    returns name of module from which the function that  is calling 
    caller() was imported

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:TimeStamp}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.TimeStamp \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{TimeStamp}(\textit{T}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    deprecated TimeStamp function (should be replaced by time module 
    formatters)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:Union}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.Union \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{Union}(\textit{ListOfSets})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    takes python list of python sets [S1,S2, ..., SN] and returns their 
    union

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:ListUnion}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.ListUnion \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ListUnion}(\textit{ListOfLists})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    takes python list of python lists

    [[l11,l12, ...], [l21,l22, ...], ... , [ln1, ln2, ...]]

    and returns the aggregated list

    [l11,l12, ..., l21, l22 , ...]

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:GetDefaultVal}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.GetDefaultVal \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetDefaultVal}(\textit{func}, \textit{varname}, \textit{NoVal}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    given a live python function object "func", return the default value 
    for variable with name "varname" if it exists as a keyword variable, 
    else return NoVal

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:MakeDir}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.MakeDir \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{MakeDir}(\textit{DirName}, \textit{creates}={\tt ()})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    is a "strong" directory maker -- if DirName already exists, this 
    deletes it first

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:MakeDirs}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.MakeDirs \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{MakeDirs}(\textit{DirName}, \textit{creates}={\tt ()})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    "strong" version of os.makedirs

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:strongcopy}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.strongcopy \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{strongcopy}(\textit{tocopy}, \textit{destination}, \textit{use2}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    "strong" version of copy -- if destination already exists, it removes 
    it first befire copying

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:delete}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.delete \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{delete}(\textit{ToDelete})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    unified "strong" version of delete that uses os.remove for a file and 
    shutil.rmtree for a directory tree

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:Log}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.Log \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{Log}(\textit{s})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Log a debug message

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:TemplateInstance}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.TemplateInstance \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{TemplateInstance}(\textit{templatepath}, \textit{outpath}, **\textit{kws})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Apply python template at "templatepath" with substitutions from keyword
    arguments **kws passed in, and write out result to outpath Useful for 
    html templating

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:MakeT}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.MakeT \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{MakeT}(\textit{r})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    If input 'r' is a comma-delimited string, return tuple split on commas,
    else return tuple(r)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:getKalong}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.getKalong \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{getKalong}(\textit{LL1}, \textit{LL2}, \textit{k})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Fast version of "K-along" paths.

    ARGUMENTS: --LL1 = numpy array of paths --LL2 = sorted numpy array of 
    paths --k = nonnegative integer

    RETURNS: [A,B] where A and B are numpy arrays of indices in LL1 such 
    that LL2[A[i]:B[i]] contains precisely those paths in B that are k 
    directory levels down from LL1[i] -- as path strings (no actual 
    directory testing is done).  A[i] = B[i] = 0 if no paths in LL2 are k 
    directory levels down from LL1[i]

    E.g. if

    LL1 = numpy.array(['../Data/Dan\_Data/', 
    '../Users/DanYamins/','../Users/SijiaWang/'])

    and

    LL2 = numpy.array(['../Data/Dan\_Data/NPR\_Puzzle\_Solutions', 
    '../Data/Dan\_Data/RandomData','../Users/DanYamins/Finance/'])

    then

    getKalong(LL1,LL2,1) = [A,B] = [[0,2,0],[2,3,0]]

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:maximalpathalong}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.maximalpathalong \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{maximalpathalong}(\textit{YY}, \textit{ZZ})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Fast function for determining indices of elements of YY such that they 
    are "path along" some element of ZZ, for numpy arrays YY and ZZ.  When 
    YY[i] is path along several element of ZZ, returns index of the first 
    occurence of the closest path.  If YY[i] is not path-along any elements
    of Z, returns ''.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:getpathalong}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.getpathalong \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{getpathalong}(\textit{YY}, \textit{ZZ})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Fast version of path long for numpy arrays. 

ARGUMENTS:
        LL1 = numpy array of paths
        LL2 = sorted numpy array of paths

RETURNS:
[A,B] where A and B are numpy arrays of indices in LL1 such 
that LL2[A[i]:B[i]] contains precisely those paths in B that are
in the directory tree of paths in LL1[i] ( as path strings -- no actual
filesystem existence testing is done).  A[i] = B[i] = 0 if no paths in 
LL2 are in the directory tree under LL1[i]
        
E.g. if 

LL1 = numpy.array(['../Data/Dan\_Data/', '../Users/DanYamins/','../Users/SijiaWang/'])

and

LL2 = numpy.array(['../Data/Dan\_Data/NPR\_Puzzle\_Solutions',     '../Data/Dan\_Data/NPR\_Puzzle\_Solutions/AmericaPensacolaPuzzle/',
'../Data/Dan\_Data/RandomData','../Users/DanYamins/Finance/'])

then

getpathalong(LL1,LL2) = [A,B] = [[0,3,0],[3,4,0]]
        
        
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:getpathalongs}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.getpathalongs \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{getpathalongs}(\textit{Y}, \textit{Z})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns numpy array of indices i in numpy array Y such that Y[i] is 
    path-along some path string in Z

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:getpathstrictlyalong}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.getpathstrictlyalong \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{getpathstrictlyalong}(\textit{YY}, \textit{ZZ})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Version of getpathalong that requires "strictly path along"

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:fastequalspairs}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.fastequalspairs \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{fastequalspairs}(\textit{Y}, \textit{Z})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}


ARGUMENTS:
        LL1 = numpy array of paths
        LL2 = sorted numpy array of paths

RETURNS:

[A,B] where A and B are numpy arrays of indices in LL1 such that:
        
        LL2[A[i]:B[i]] = LL1[i].   
        
A[i] = B[i] = 0 if LL1[i] not in LL2
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:ModContents}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.ModContents \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ModContents}(\textit{obj}, \textit{Cond}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Modified version of Contents function, avoiding recursive inspection
of objects that satisfy condition Cond 

ARGUMENTS:
--obj = BeautifulSoup object
--Cond = two-place boolean function with arugments (o1,o2) where 
        o1,o2 are meant to be BeautifulSoup objects

If Cond = None this is the same as Contents 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:Contents}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.Contents \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{Contents}(\textit{obj})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Convenience function for working with BeautifulSoup contents objects 
    (move this somewhere else?)

    ARGUMENT: --obj = BeautifulSoup object.

    Given BeautifulSoup object 'obj', extract the "string contents" 
    recursively.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:fastisin}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.fastisin \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{fastisin}(\textit{Y}, \textit{Z})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    fast routine for determining indices of elements in numpy array Y that 
    appear in numpy array Z

    returns boolean array of those indices

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:FastRecarrayEquals}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.FastRecarrayEquals \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FastRecarrayEquals}(\textit{Y}, \textit{Z})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    fast routine for determining whether numpy record array Y equals record
    array Z

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:FastRecarrayEqualsPairs}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.FastRecarrayEqualsPairs \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FastRecarrayEqualsPairs}(\textit{Y}, \textit{Z})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:IsDotPath}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.IsDotPath \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{IsDotPath}(\textit{s}, \textit{path}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Determine whether s is possible valid dot path of a python module, and 
    is more accurante when the putative real (relative) file path is given 
    in path.   (If path argument is given this requires path to be a 
    DataEnvironment-relative path, starting with ../)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:FastRecarrayIsIn}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.FastRecarrayIsIn \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FastRecarrayIsIn}(\textit{Y}, \textit{Z})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Fast routine for determining which records in numpy record array Y 
    appear in record array Z

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:FastRecarrayDifference}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.FastRecarrayDifference \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FastRecarrayDifference}(\textit{X}, \textit{Y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    fast routine for determining which records in numpy array X do not 
    appear in numpy array Y

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:fastarraymax}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.fastarraymax \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{fastarraymax}(\textit{X}, \textit{Y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

fast way to achieve: 

ARGUMENTS:
        X,Y numpy arrays of equal length
RETURNS:
        Z where Z[i] = max(X[i],Y[i])
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:fastarraymin}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.fastarraymin \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{fastarraymin}(\textit{X}, \textit{Y})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

fast way to achieve: 

ARGUMENTS:
        X,Y numpy arrays of equal length
RETURNS:
        Z where Z[i] = min(X[i],Y[i])
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:SimpleStack}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.SimpleStack \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{SimpleStack}(\textit{seq}, \textit{UNIQIFY}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Vertically stack sequences numpy record arrays. Avoids some of the 
    problems of numpy.v\_stack

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:SimpleStack1}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.SimpleStack1 \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{SimpleStack1}(\textit{seq}, \textit{UNIQIFY}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Vertically stack sequences numpy record arrays. Avoids some of the 
    problems of numpy.v\_stack but is slower

    if UNIQIFY set to true, only retains unique records

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:SimpleColumnStack}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.SimpleColumnStack \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{SimpleColumnStack}(\textit{seq})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Stack columns in sequences of numpy record arrays. Avoids some of the 
    problems of numpy.c\_stack but is slower

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:RemoveColumns}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.RemoveColumns \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{RemoveColumns}(\textit{recarray}, \textit{ToRemove})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given numpy recarray and list of column names ToRemove, return recarray
    with columns whose names are not in ToRemove

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:MaximalCommonPath}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.MaximalCommonPath \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{MaximalCommonPath}(\textit{PathList})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given list of paths, return common prefix.  Like 
    os.path.commonprefixbut proper for Data Environment purposes.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:Backslash}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.Backslash \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{Backslash}(\textit{Dir}, \textit{Verbose}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Adds '/' to end of a path (meant to make formatting of directory Paths 
    consistently have the slash)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:MakeDirWithDummy}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.MakeDirWithDummy \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{MakeDirWithDummy}(\textit{Dir})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    makes a directory with a empty file 'dummy' in it

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:MakeDirWithInit}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.MakeDirWithInit \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{MakeDirWithInit}(\textit{Dir})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    makes a directory with an empty file '\_\_init\_\_.py' in it

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:GetTimeStampedArchiveName}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.GetTimeStampedArchiveName \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetTimeStampedArchiveName}(\textit{toarchive})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    given path string, return corresponding name that it would have in the 
    Archive, with timestamp attached

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:copy_to_archive}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.copy\_to\_archive \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{copy\_to\_archive}(\textit{toarchive}, \textit{depends\_on}={\tt ('../',)}, \textit{creates}={\tt ('../Archive/',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    copy file or directory to archive with proper archive name

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:move_to_archive}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.move\_to\_archive \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{move\_to\_archive}(\textit{toarchive}, \textit{depends\_on}={\tt ('../',)}, \textit{creates}={\tt ('../Archive/',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    move file or directory to archive with proper archive name

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:CompilerChecked}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.CompilerChecked \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{CompilerChecked}(\textit{ToCheck})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    cleans a list of strings representing python regular expressions 
    ToCheck, returning only those that are not empty and properly compile

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:CheckInOutFormulae}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.CheckInOutFormulae \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{CheckInOutFormulae}(\textit{ExpList}, \textit{S})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given a list ExpList of Regular expression strings and "NOT '-prefixed 
    regular expression strings, return list of all strings in list S that: 
    -- match at least one of the expressions in ExpList that are \_not\_ 
    prefixed by 'NOT ' -- match none of the expressions in ExpList that 
    \_are\_ prefixed by 'NOT '

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:AddInitsAbove}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.AddInitsAbove \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{AddInitsAbove}(\textit{opfile})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given a python to a pytho module opfile, add an empty \_\_init\_\_.py 
    file to the directory containing opfile, if not such file exists. Reset
    mod time of directory so it appears as if nothing as changed.

    The intent of this is to allow python modules to be placed in 
    directories in the Data Environment and then be accessed by package 
    imports, without the user having to remember to put the 
    '\_\_init\_\_.py' in the directory that the module is in.   The 
    timestamp of the containing directory is reset if the \_\_init\_\_.py 
    is added to make sure that no stupid re-computations are done that make
    it appear as if things have changed when the havent.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:DictInvert}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.DictInvert \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{DictInvert}(\textit{D})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

ARGUMENT:
        dictionary D
OUTPUT:
--dictionary whose keys are unique elements of values of D, and 
whose values on key 'K' are lists of keys 'k' in D such that D[k] = K
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:PathExists}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.PathExists \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{PathExists}(\textit{ToCheck})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

convenient name for os function

The reason it's done this way as opposed to merely setting 
        PathExists = os.path.exists
in this module is that this will disturb the system i/o intercept because this module needs to be execfiled FIRST before system\_io\_override. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:Rename}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.Rename \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{Rename}(\textit{src}, \textit{dest})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

convenient name for os function

The reason it's done this way as opposed to merely setting 
        PathExists = os.path.exists
in this module is that this will disturb the system i/o intercept because
this module needs to be execfiled FIRST before system\_io\_override. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:IsDir}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.IsDir \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{IsDir}(\textit{ToCheck})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

convenient name for os function

The reason it's done this way as opposed to merely setting 
        PathExists = os.path.exists
in this module is that this will disturb the system i/o intercept because this
module needs to be execfiled FIRST before system\_io\_override. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:IsFile}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.IsFile \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{IsFile}(\textit{ToCheck})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

convenient name for os function

The reason it's done this way as opposed to merely setting 
        PathExists = os.path.exists
in this module is that this will disturb the system i/o intercept 
because this module needs to be execfiled FIRST before system\_io\_override. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:FindAtime}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.FindAtime \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FindAtime}(\textit{ToAssay})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

convenient name for os function

The reason it's done this way as opposed to merely setting 
        PathExists = os.path.exists
in this module is that this will disturb the system i/o intercept
because this module needs to be execfiled FIRST before system\_io\_override. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:listdir}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.listdir \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{listdir}(\textit{ToList})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

convenient name for os function

The reason it's done this way as opposed to merely setting 
        PathExists = os.path.exists
in this module is that this will disturb the system i/o intercept
because this module needs to be execfiled FIRST before system\_io\_override. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:ListAnd}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.ListAnd \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ListAnd}(\textit{iterable})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return True if bool(x) is True for all values x in the iterable.

\setlength{\parskip}{1ex}
      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      bool

      \end{quote}

    \end{boxedminipage}

    \label{System:Utils:ListOr}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.ListOr \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ListOr}(\textit{iterable})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return True if bool(x) is True for any x in the iterable.

\setlength{\parskip}{1ex}
      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      bool

      \end{quote}

    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.BadCheckError \textit{(class)}|(}
\subsection{Class BadCheckError}

    \label{System:Utils:BadCheckError}
Error class used for raising I/O errors (maybe should be moved to 
system\_io\_override?)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{System:Utils:BadCheckError:__init__}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.BadCheckError \textit{(class)}!System.Utils.BadCheckError.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{iofunc}, \textit{readfiles}, \textit{writefiles}, \textit{Dependencies}, \textit{Creates})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.BadCheckError \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.multicaster \textit{(class)}|(}
\subsection{Class multicaster}

    \label{System:Utils:multicaster}
\begin{alltt}

Class creating object that multicasts a string output stream to have both
its original desired effect and also to print any output to a log file. 

typical Usage:
        sys.stdout = multicaster(sys.\_\_stdout\_\_,'LogFile.txt')

Then, whenever a 'print ' statement is made, output is directed both to
original stdout as well as to the logfile "LogFile.txt"
\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{System:Utils:multicaster:__init__}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.multicaster \textit{(class)}!System.Utils.multicaster.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{filename}, \textit{OldObject}, \textit{New}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

ARGUMENTS:
        filename = name of file to write to 
        OldObject = original output stream to multicast
        NEW = boolean which overwrites log file if true; otherwise, 
        output of stream is \_appended\_ to 'filename'    
        
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:multicaster:__getattr__}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.multicaster \textit{(class)}!System.Utils.multicaster.\_\_getattr\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_getattr\_\_}(\textit{self}, \textit{name})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    This is intended to answer that whenever the stdout is asked to do 
    something other than write the  function is undisturbed.  If the stdout
    object were its own class (instead of it being merely a file 
    {\textbackslash}object that is being used for the purpose of output), 
    this would be unneccesary, we'd simple subclass the stdout object.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Utils:multicaster:write}
    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.multicaster \textit{(class)}!System.Utils.multicaster.write \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{write}(\textit{self}, \textit{s})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{System \textit{(package)}!System.Utils \textit{(module)}!System.Utils.multicaster \textit{(class)}|)}
    \index{System \textit{(package)}!System.Utils \textit{(module)}|)}
