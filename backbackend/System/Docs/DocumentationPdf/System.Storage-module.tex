%
% API Documentation for DataEnvironment
% Module System.Storage
%
% Generated by epydoc 3.0.1
% [Tue Mar 31 17:17:20 2009]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{System \textit{(package)}!System.Storage \textit{(module)}|(}
\section{Module System.Storage}

    \label{System:Storage}
\begin{alltt}

===========
Routines for storing and retrieving information about files and python objects. 
===========

In the Data Environment, which is devoted to understanding and managing dependency links, 
routines throughout the system often require stored information about files, directories, 
functions, and data structures.   This information may include:
                
1) Information that can't directly be determined by analyzing the file or directory:  
for example, the file's last modification-time or create-time.    This information is 
often necessary to determine when an object has changed, so as to know when to 
trigger the re-running of a process that depends on the object.   This is the case
with the function PropagateThroughLinkGraphWithTimes, in the LinkManagement 
module, which needs to compare link target's mod times to link source's mod 
times to know when to re-run a data-creation script. 

or,             

2) Information that is that \_is\_ possible to glean upon complex introspection but hard 
to obtain otherwise: for example, the list of names of python functions that might be called 
by another function during its run.  This information is useful to analyze an object to 
determine what its dependencies are in the first place.   This is the case with the function 
ComputeLinksFromOperations, which determines the data "depends\_on" and "creates", 
and functional "uses",  from a python function's code.  
                
This module provides a unified interface to obtain such information so that  it can be 
called up wherever needed.   The key realizaion is that providing unified access to the
relevant information about the objects boils down to having a unified method for 
\_storing\_ and retrieving "stylized versions" of those objects,  versions that contain 
somewhat detailed information about the objects' parts, as well as information about
when those parts were last modified.   

This is because:

1) if you need to get information about when an object has changed, you'll need to have a 
stored version that can be compared to the current version to detect chages, together 
with timing information about each of those stored parts so that if the part \_hasn't\_ 
changed you can tell what the last actual mod-time of the part was. 

and     

2) to provide easy access to complex introspected information, it makes sense to 
compute that introspection only once per object per modification, and store the
results of that introspection in a standardized format in a single place. 
                
The  "data model" behind our approach to doing this enables us to be as lazy as possible, 
leaving as much to operating system as we can.  The basic idea is that every object 
stored on disk in the Data Environment file system is one of two things:
        1) A directory or a file inside a directory  -- whose properties are "at the operating system level" 
                and which don't need to be made "live" to access
or
        2) an implied object \_\_inside\_\_ a file -- whose properties are "more specific than
        the operating system level" and which require some form of "being live" to access
                
For instance, a python package consists of a directory containing python .py files, and
in turn each py file is a module containing python objects.  Or a relational database, 
which is at one level a filesystem, but which at a lower level consists of records. 

Now, for information about things at the files and directories levels, we are able to 
rely mostly on things provided by the operating system: it obviously already stores 
the files themselves, and provides access to file and directory modification 
information, through things like the 'stat' and 'diff' utilities.     However, for finer 
detail, we need to supplement the operating system.   The basic strategy is:
        -- for each of several "Special Supported File Types", store information about the 
        more detailed parts of the supported file type
and then
        -- provide an \_extension\_ of the stat and diff utilities that allows queries to specify 
        both a file path, as well as a more detailed  part-name.

For instance, the standard python implementation of the path mod-time function is 
'getmtime' function in the the os.path module.  The function os.path.getmtime takes
as argument a single path, and returns the time of last modification of that path.   
Here, we extend that function to the FindMtime function which takes both a pathname 
argument, as well as an "object-name" argument, and which returns the mod-time of 
that specific object.  For the moment, we only have one "Special Supported File Type":  
python modules ; so the "objectname" argument boils down to a "function-name" 
argument that allows one to find the mod-time for a given function in a module.   
All other files are treated at the atomic level.  (In the future, other kinds of file parts
could be stored, e.g. records in a database by integrating database query routines .... etc...)
        
\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{System:Storage:FindMtime}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.FindMtime \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FindMtime}(\textit{path}, \textit{objectname}={\tt ''}, \textit{HoldTimes}={\tt None}, \textit{Simple}={\tt True}, \textit{depends\_on}={\tt ('../System/StoredModules/',)}, \textit{creates}={\tt ('../System/StoredModules/',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

This is the main unified interface to path and path-part mod times that 
is to be used throughout the system.  

ARGUMENTS:
--path = path whose mod-time is to be assessed  
--objectname = name of object within that path, whose mod-time is to be assessed. 
--HoldTimes = Dictionary, where:
        --keys are paths
        --HoldTimes[Path] is a timestamp that the system is meant to "pretend" 
        is the mod time of Path, if Path comes up as a source or target during the 
        propagation process, instead of computing the real mod time. 
-- Simple = Boolean : if True, only looks just at the modtime of path; if False, 
and if path is a directory, it looks recursively through the mod times of files
inside path and returns the maximum.  

RETURNS:
-- floating point number representing a mod-time, in seconds since the start of the  
Unix Epoch.  (Jan 1, 1970 at 00:00:00 GMT). 
        
NB: For the moment, the object name parameter only does anything if the path
is a python module, and if then only if the objectname names an object defined 
in that python module.   The way this is determined is by a combination of
"live analysis" -- e.g importing the python module and inspecting its contents 
via introspection methods;  and "static analysis" which relies on analyzing 
python code without importing the module but which does require building 
the compiler parse tree for the code.  If either the importing step or the 
compiler parse-tree step fails, the function just returns the mod-time of the 
file that the module is in.  [All of this is sort of built haphazardly in to the 
way the FindMtime function and its depedencies are written.  In the future, 
to accommodate other "Special File Types", the way this and associatd 
functions are written would be to be made more modular.] 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:ListFindMtimes}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.ListFindMtimes \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ListFindMtimes}(\textit{FileParts}, \textit{HoldTimes}={\tt None}, \textit{Simple}={\tt True}, \textit{Parallel}={\tt True}, \textit{depends\_on}={\tt ('../System/StoredModules/',)}, \textit{creates}={\tt ('../System/StoredModules/',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Given a list of files and objects within those files, computes mtimes for them. 
This is an optimization on top of FindMtimes, by inspecting a list of file/object pairs,
then analyzing the uniquely mentioned files only once. 

ARGUMENTS:
--FileParts: a python list of pairs (FileName, ObjectName) each of which is to 
be analyzed for mod-time.   If only a FileName is meant to provided, 
e.g. no subpart is to be looked for, just the mod-tiem fo the whole file, 
than ObjectName should be set to equal FileName.  
        
For instance to get the modtime of the function "GetBasketBallTeams"
in the file:

'../Users/Elaine/Playbox/Sports/ESPN\_NBA/NBA\_Teams.py' 

you'd include in the list the pair:

('../Users/Elaine/Playbox/Sports/ESPN\_NBA/NBA\_Teams.py',
'Users.Elaine.Playbox.Sports.ESPN\_NBA.NBA\_Teams.GetBasketBallTeams')

but to get the modtime of the file:

'../Users/Elaine/Playbox/Sports/ESPN\_NBA/NBATeamData.data', 

you'd include the pair

('../Users/Elaine/Playbox/Sports/ESPN\_NBA/NBATeamData.data', '../Users/Elaine/Playbox/Sports/ESPN\_NBA/NBATeamData.data')
        
--HoldTimes, Simple are the same as the correpsonding FindMtimes arguments
--Parallel = boolean indicating whether the function should be executed in 
parallel on multiple processors in a machine (if available)

Returns:
A dictionary, where:
        --the keys are the unique object names (which are same as the
        file names when no specific sub-object is to be given) 
        --the value at a key is the same as would be there if 
        FindMtims(FileName,ObjectName) were called.     
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:BlockUpdateModuleStorage}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.BlockUpdateModuleStorage \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{BlockUpdateModuleStorage}(\textit{L})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:GetStoredModule}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.GetStoredModule \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetStoredModule}(\textit{path})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns stored module for the python module whose file is at 'path'. If
    the module storage update process fails, this function returns None. 
    The format of the returned object is a dictionary where each key is the
    name of the module parts, and the value at the key is the instance of 
    the StoredModulePart class for that part.  (see below in 
    StoredModulePart for details)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:GetStoredModuleTimes}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.GetStoredModuleTimes \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetStoredModuleTimes}(\textit{path})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns stored module's mod times for the python module whose file is 
    at 'path'. If the module storage update process fails, this function 
    returns None. The format of the returned object is: a dictionary whose 
    keys are the same as the keys of the stored module dctionary, and whose
    values on those keys are mod times for the parts.   (There's an extra 
    key called '\_\_hash\_\_' which stores a hash of the stored module 
    dictionary to ensure data integrity upon update.)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:GetNestedObject}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.GetNestedObject \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetNestedObject}(\textit{name}, \textit{Members})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Technical dependency of ExtractParts

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:GetExtendedMembers}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.GetExtendedMembers \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetExtendedMembers}(\textit{obj}, \textit{Static})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Technical dependency of ExtractParts

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:GetExtendedExecedNames}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.GetExtendedExecedNames \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetExtendedExecedNames}(\textit{Execed}, \textit{Static})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Technical dependency of ExtractParts

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:ExtractParts}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.ExtractParts \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ExtractParts}(\textit{obj}, \textit{Execed}={\tt None}, \textit{Static}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Given a python object obj, extract it for storage.   This is called by the function
UpdateModuleStorage and the class StoredModulePart. 

ARGUMENTS:
--obj = the python object to get stored parts of --- as "made live" by having 
        been imported in a module ultimately in UpdateModuleStorage.   
--Execed = an \_execfile'd\_\_ version of the same object, as opposed to imported.  
--Static = the static analysis version of the object. 
        
Returns:
--Dictionary whose keys are the names of parts of the object and whose 
values on each key are the stored versions of the part with that name.
        
NOTE:  The execfiled and static analysis objects supplement and 
verify the information stored about the object. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:UpdateModuleStorage}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.UpdateModuleStorage \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{UpdateModuleStorage}(\textit{path})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Updates the file storing the module at path 'path', as well
as the file storing the mod-times for those parts.   

ARGUMENT:
-- path = the path of the module whose storage is to be updated 
                
RETURNS:
-- Nothing.  But it updates the module storage.   To get at the 
stored objects you use one of the two functions 
(GetStoredModule or GetStoredModuleTines)
                
The basic format of storage is:  given a module file, to associate 
two storage files with it:  
        1) a file containing a pickling of a StoredModule dictionary 
        containing stored versions of the parts of the module, 
        at path StoredModulePath, and 
        2) a file containing a pickling of a StoredModuleTimes dictionary
        containing the Modtimes for each of the stored parts, 
        at path StoredTimesPath.  

The StoredModule dictionary's format is to associated to each part-name
an instance of the StoredModulePart class:
        StoredModule[ part-name ] =   StoredModulePart(part), 
See comments in StoredModulePart class for details. 
                
The StoredModuleTimes format is a dictionary whose keys are the same
as the keys of the StoredMdule dictionary, and whose values on those
keys are mod times for the parts.   
(There's an extra key called '\_\_hash\_\_' which stores a hash of the stored
module dictionary to ensure data integrity upon update.) 
        
The reason that the StoredTimes file is stored separately from the 
StoredModules file, instead of in one big dictionary is that this way, 
the much smaller StoredTimes dictionary can be loaded for use in 
evaluating functions like FindMtime, without having to lead the 
whole module storage.  

This function basically has two stages:

1) First, determine whether the module's object storage is:
        -- Update to date, in which case nothing has to be done
        -- In OK format but may not be up to date, in which
                case the module nees to be imported and analyzed, 
                the results compared to the stored version
        -- Non-existent or somehow contaminated or in the wrong format,
                in which case it needs to be remade from scratch.                               
                        
2) Having determined which state the storage is in, and if the 
module storage needs to be updated, act upon that.    
The action consists of:
        - pickle-loading the StoredModule already on disk if it exists, 
                (as well as the stored module mod times, which is already 
                unpickled in stage 1 of this function) 
        -- computing a new version of the stored module,
        -- for each part in the new Stored module, comparing it to the stored 
                version already on disk, and if the part hasn't changed, retain the old mod time,
                but if it has changed or is a new part not yet stored, set the stored 
                mod time the mod time of the file the module is in. 
                -- if the part has been removed, remove it from storage. 
                
Along the way, the function prints out small messages describing
the modification state of parts, if any modifications appear to have been made.                         
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:ClassMethodDumps}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.ClassMethodDumps \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ClassMethodDumps}(\textit{obj})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Storage method for class methods.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:FunctionDumps}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.FunctionDumps \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FunctionDumps}(\textit{obj})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Storage method for functions.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:CodeEquals}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.CodeEquals \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{CodeEquals}(\textit{c1}, \textit{c2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Equality testing for code objects.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:GetStoredPathNames}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.GetStoredPathNames \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetStoredPathNames}(\textit{path})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Determines path names from stored module and stored module times 
    obects, from path name of the module to be stored.

\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.StoredModulePart \textit{(class)}|(}
\subsection{Class StoredModulePart}

    \label{System:Storage:StoredModulePart}
This class defines the storage for a module. Calling 
StoredModulePart(object) creates a storable version of the live object.

If it were possible to pickle all kinds of python objects,      this class 
would be unnecssary -- we'd just use the Pickle.dumps method.    However, 
it is not possible to run standard python pickling on all python objects.

This is for two reasons:

1) Some python objects require special pickling methods -- e.g. code 
objects require "marshal" -- because cPickle wasn't built to handle them 
(for good reason).  But since we want to store many objects types together,
we have to have a single interface for all the various kinds of storing.

2) The standard of "being picklable" means that the pickle.load method has 
to completely restore the unpickled object to fully functional form. This 
is basically impossible for things like functions or class methods or 
modules because they rely on defined names in the module context or from 
other modules, so no pickling method for them exists.   But for our 
purposes we don't actually need to require so high a standard of our 
storage: we don't need to use the stored objects as live substitutes for 
the real objects, we merely need just to be able to recover enough detail 
to be able to determine whether the live real object differs in some 
material way from the stored one.

This StoredModulePart class basically does two things therefore: 1) unifies
all the various pickling methods to do exist into a single interface, and 
2) extracts data about the objects into a set of objects that are "dry" 
enough that they \_can\_ be pickled, but which are descriptive enough to 
provide the ability to make meaningful comparisons to check for 
modifications.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{System:Storage:StoredModulePart:__init__}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.StoredModulePart \textit{(class)}!System.Storage.StoredModulePart.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{obj}, \textit{ScopeName}={\tt None}, \textit{Static}={\tt None})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:StoredModulePart:reconstitute}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.StoredModulePart \textit{(class)}!System.Storage.StoredModulePart.reconstitute \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{reconstitute}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:Storage:StoredModulePart:__eq__}
    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.StoredModulePart \textit{(class)}!System.Storage.StoredModulePart.\_\_eq\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_eq\_\_}(\textit{self}, \textit{other})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                            Class Variables                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Class Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-m\-o\-d\-u\-l\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt 'System.Storage'}&\\
\cline{1-2}
\end{longtable}

    \index{System \textit{(package)}!System.Storage \textit{(module)}!System.Storage.StoredModulePart \textit{(class)}|)}
    \index{System \textit{(package)}!System.Storage \textit{(module)}|)}
