%
% API Documentation for DataEnvironment
% Module System.LinkManagement
%
% Generated by epydoc 3.0.1
% [Tue Mar 31 17:17:20 2009]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}|(}
\section{Module System.LinkManagement}

    \label{System:LinkManagement}
\begin{alltt}

Functions that are used to extract and explore data dependency links.

The basic idea is that:   
-- Some of these functions \_FIND\_ user-made python modules 
(e.g. the scripts written by the user to make data computations
-- Some of these functions \_\_ANALYZE\_\_ user-made python modules 
        to determine what data dependency links they contain
-- Some of these functions allow you to \_\_EXPLORE\_\_ 
        the dependency network described by these links 
\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{System:LinkManagement:LinksFromOperations}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.LinksFromOperations \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{LinksFromOperations}(\textit{FileList}, \textit{Aliases}={\tt None}, \textit{AddImplied}={\tt False}, \textit{AddDummies}={\tt False}, \textit{FilterInternal}={\tt True}, \textit{depends\_on}={\tt ('../',)}, \textit{creates}={\tt ('../System/StoredLinks/',)}, \textit{Recompute}={\tt False}, \textit{Parallel}={\tt True})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Analyzes a set of python modules to find data dependency links present in the 
modules.   Overall, this function does two things:  

1) it writes out files that cache the links computed, and uses these cached 
        versions to increase speed when the function is called again;
and

2) it returns the list of links, as a numpy record array.  
        
Arguments:
--FileList = list of python modules to analyze, as a list of path strings. 
--AddImplied = Boolean, which if True, adds implied links to the numpy array 
        that is returned 
--AddDummies = Boolean, which if True, adds Dummy links to the numpy record 
        array that is returned 
--FilterInteral = Filter returned list of links so that links between 
        files and modules that are not in FileList are removed. 
--Recompute = Boolean which if True causes the system to ignore 
        cached LinkLists and recompute everything from scratch.
--Parallel = The algorithm includes the ability to parallelize if the system is
        being computed on has multiple processors.  If this boolean is True
        (the default) parallel computation is done. 
        
Returns:
        A
where A is a numpy array describing the LinkList 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:GetImpliedLinks}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.GetImpliedLinks \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetImpliedLinks}(\textit{NewLinks}, \textit{LinkList})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    This computes the implied links --- assuming that all implied links in 
    the "LinkList" argument have already by computed, it only computes the 
    implied links that will be added by the addition of the NewLinks.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:SameRoot}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.SameRoot \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{SameRoot}(\textit{X}, \textit{Y})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:GetDummyLinks}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.GetDummyLinks \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetDummyLinks}(\textit{NewLinks}, \textit{LinkList})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    This computes the dummy links --- assuming that all dummy links in the 
    "LinkList" argument have already by computed, it only computes the 
    dummy links that will be added by the addition of the NewLinks.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:GutsComputeLinks}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.GutsComputeLinks \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GutsComputeLinks}(\textit{FileList})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

This function actually computes the links contained
in the files in FileList

Argument: 
FileList == list of modules to analysis

Returns:
LinkList == list of links computed
Succeeded List = list of modules in FileList whose links 
        could be successfully obtained.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:ParallelComputeLinksFromOperations}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.ParallelComputeLinksFromOperations \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ParallelComputeLinksFromOperations}(\textit{FileList}, \textit{Parallel}={\tt True}, \textit{creates}={\tt ('../',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Parallel wrapper for GutsComputeLinks

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:GetStoredDefaultVal}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.GetStoredDefaultVal \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetStoredDefaultVal}(\textit{op}, \textit{name}, \textit{NoVal}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Given a python fnction in the form of a "Stored Operation", 
return the function's default value for a given variable name, 
returning NoVal if the variable doesn't exist for the function or doesn't 
have a default value. 
        
E.g. if the function is 
                def F(x, y=3): ... 
Then if op is the "Stored Operation" form of F, 
        GetStoredDefaultVal(op,y) returns '3' , 
while 
        GetStoredDefaultVal(op,x,[]) returns '[]'.

ARGUMENTS:
op -- a "Stored operation" -- Suppose you have a python function F.  
Then the "Stored Operation" version of the function is a dictionary with:
key 'func\_code' -- so that 
        op['func\_code'] = F.func\_code, 
the python code object associated with F, and key 'func\_defaults'
-- so that 
        op['func\_defaults'] = F.func\_defaults,
the tuple of default values of F.               

name -- name of variable that you want to determine default value if
        
NoVal -- object to substitute in if the named variable does not exist for F 
or if it that variable does not have a default value
        
Returns 
        The default value when it exists, otherwise NoVal
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:ReduceListOfSetsOfScripts}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.ReduceListOfSetsOfScripts \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ReduceListOfSetsOfScripts}(\textit{ScriptList})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given a list of sets of scripts, produces a reduced version retaining 
    only the \_last\_ call to any given script.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:GetLinksBelow}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.GetLinksBelow \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetLinksBelow}(\textit{Seed}, \textit{Exceptions}={\tt None}, \textit{Forced}={\tt False}, \textit{Simple}={\tt False}, \textit{Pruning}={\tt True}, \textit{ProtectComputed}={\tt False}, \textit{depends\_on}={\tt ('../',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given a Seed list of paths, loads the LinkList of live modules, and 
    determines dowstream data dependency links by propagating downstream 
    through the LinkList, from paths that are in Seed.

    ARGUMENTS: Seed = list of paths from which to propagate downstream.

    Forced = Boolean : if true, propagates links through LinkList without 
    regard to timestamps of files, catching \_all\_ downstream links, even 
    if the files they represent are up to date. If Forced is False -- which
    is the default -- this progates down only through links that are in 
    need of updating, as determined by time stamps. (e.g. those link 
    targets whose timestamps are old than their sources -- and all the 
    downstream files -- are included.)

    Simple = Boolean : if True, only looks at paths listed explicitly in 
    Seed; if False, looks at all paths in Seed, as well as those in 
    directories contained in the filesystem below  paths in Seed

    ProtectComputed = Boolean : if True, progates through links where 
    target data files of links have been modified \_after\_ they were last 
    created by system update of the link, e.g. as if the data had been 
    corrupted after computation. Such files have a newer timestamp than 
    their sources, so merely propagating from newer sources to older 
    targets will not capture these files where computations (may) have been
    corrupted.     Often times, one wishes to make a temporary change in a 
    mid-stream file and see what its consequnces are, so in this case the 
    ProtectComputed option should be left at its default value of False.

    Exceptions = List : Before propagating downstream through the list, 
    this function first filters out links whose scripts that are not 
    indicated for Automatic updating (see below for comments in the 
    function body). Exceptions is a list of scripts whose links should be 
    retained even if they are not indicated for Automatic updating -- the 
    point of this is mostly for the function MakeUpdated (see comments in 
    that function).

    RETURNS: A = [L0,L1,L2 ...., LF] where A[i]  = Li is sublist of links 
    in the LinkList, representing those links activated at stage i in the 
    downstream propagation through the LinkList from the seed links in L0.

    In words, this is a trace through the Directred Acyclic Graph 
    represented by the LinkList. Note that the same link can appear 
    multiple times in different stages because it might be activated first 
    by itself (e.g. because its source is in Seed and its target is older 
    than its source) and then by virtue of downstream propagation from some
    independently activated link upstream.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:GetII}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.GetII \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetII}(\textit{LinkList}, \textit{Seed})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:UpdateGuts}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.UpdateGuts \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{UpdateGuts}(\textit{UpdateList}, \textit{LinkList}, \textit{MtimesDict}, \textit{PtimesDict}, \textit{ProtectComputed})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

The guts of the downstream propagation through a linklist.   
Used primarily by the function PropagateThroughLinkGraphWithTimes.

ARGUMENTS:
LinkList = A numpy record array of data dependency links.

UpdateList = List of the form [(i1,t1),(i2,t2), ... , (in,tn)] where 
each  i is an index in LinkList, and ti is a time stamp (or a 'numpy.nan')

MtimesDict = Dictionary where:
-- the keys are some of the elements of LinkList['LinkSource'] 
        or LinkList['LinkTarget'] 
   These are paths in filesystem, or subparts of paths. (e.g. functions inside .py 
   module files)
-- the values values on key LinkList['LinkSource'][i] is 

FindMtime(Linklist['SourceFile'][i],functionname=LinkList['LinkSource'][i]) 

these are the timestamps associated with a path or a subpart of a path
                        
ProtectComputed = Boolean : if true, enables propagation along links 
whose targets have been modified after creation

PtimesDict = Dctionary used when ProtectComputed = True, where:
-- the keys are paths in filesystem
-- the values on a key P is the most recent time that the file or 
directory at time P was successfully computed by the automatic 
updating facility  
                
RETURNS:
TargetRecs a numpy record array of containing list of links in
LinkList that are activated, relative to the information provided 
in the UpdateList.  Essentially these are:

-- all those links (source,target) in LinkList[i[0] for i in UpdateList]  
such that MtimesDict[target] is less than then T, where T is maximum of:
        MtimesDict[source] 
and
        the maximum of 
        
        [i[1] for i such that LinkList['LinkSource'][i[0]] == source]

-- plus those that are activated when ProtecteComputed is True                  
                        
Some Information is appended to each link that is activated, 
including the "maximal propagation time" along the link -- which is:
        -- T, in the case of a "Uses" link   
        -- numpy.nan, in the case of "CreatedBy" link
                
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:PropagateThroughLinkGraphWithTimes}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.PropagateThroughLinkGraphWithTimes \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{PropagateThroughLinkGraphWithTimes}(\textit{Seed}, \textit{LinkList}, \textit{Simple}={\tt False}, \textit{Pruning}={\tt True}, \textit{HoldTimes}={\tt None}, \textit{ProtectComputed}={\tt False}, \textit{depends\_on}={\tt ('../',)}, \textit{creates}={\tt ('../System/MostRecentTrace.dot',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Given a Seed list of paths, and Linklist propagates downstream 
through the LinkList from the Seeds, taking into account 
timestamps along the way. 

ARGUMENTS:
Seed = List of paths to start with. 

LinkList = numpy record array of data dependency Links.

Simple = Boolean : if True, only looks at paths listed explicitly in Seed;
if False, looks at all paths in Seed, as well as those in directories 
contained in the filesystem below  paths in Seed

ProtectComputed = Boolean : if True, progates through links 
where target data files of links have been modified \_after\_ they 
were last created by system update of the link, e.g. as if the data 
had been corrupted after computation.  

HoldTimes = Dictionary, where:
-- keys are paths
-- HoldTimes[Path] is a timestamp that the system is meant 
to "pretend" is the mod time of Path, if Path comes up as a 
source or target during the propagation process, 
instead of computing the real mod time. 
                
RETURNS:
        A = [L0,L1,L2 ...., LF]
where A[i]  = Li is sublist of links in the LinkList, representing 
those links activated at stage i in the downstream propagation 
through the LinkList from the seed links in L0.  

In words, this is a trace through the Directred Acyclic Graph 
represented by the LinkList.   Note that the same link can appear 
multiple times in different stages because it might be activated 
first by itself (e.g. because its source is in Seed and its target is 
older than its source) and then by virtue of downstream propagation 
from some independently activated link upstream. 
        
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:PropagateThroughLinkGraph}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.PropagateThroughLinkGraph \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{PropagateThroughLinkGraph}(\textit{Seed}, \textit{LinkList}, \textit{depends\_on}={\tt ('../',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Given a Seed list of paths, and Linklist propagates downstream 
through the LinkList from the Seeds. 

ARGUMENTS:
--Seed = List of paths to start with.   
--LinkList = numpy record array of data dependency Links.
                                        
RETURNS:
        A = [L0,L1,L2 ...., LF]
where A[i]  = Li is sublist of links in the LinkList, 
representing those links activated at stage i in the downstream 
propagation through the LinkList from the seed links in L0.  
        
In words, this is a trace through the Directred Acyclic Graph 
represented by the LinkList.   Note that the same link can appear
multiple times in different stages because it might be activated 
first by itself (e.g. because its source is in Seed and its target is 
older than its source) and then by virtue of downstream 
propagation from some independently activated link upstream. 
                
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:PropagateUpThroughLinkGraph}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.PropagateUpThroughLinkGraph \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{PropagateUpThroughLinkGraph}(\textit{Seed}, \textit{LinkList}, \textit{depends\_on}={\tt ('../',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Like PropagateThroughLinkGraph, but goes upstream from Seed instead of 
    downstream.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:PropagateSeed}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.PropagateSeed \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{PropagateSeed}(\textit{Seed}, \textit{LinkList}, \textit{N1}, \textit{N2}, \textit{N3}, \textit{Special})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Does the maing propagation of a seed through a linklist.   
A fairly general graph propagation function.  In words, 
this is a (basically) a trace through the Directred Acyclic Graph 
represented by interpreting (LinkList[N1],LinkList[N2]) as the 
edges of a graph -- together with the implied paths by path inclusion.   
        
ARGUMENTS:
--Seed = List of paths to start with. 
--LinkList = numpy record array of data dependency Links.       
--N1 = Column header in LinkList ; Representing the "source" column
--N2 = Column header in LinkList ; Representing the "target" column
                
RETURNS:
        A = [L0,L1,L2 ...., LF]
where A[i]  = Li is sublist of links in the LinkList, 
representing those links activated at stage i in the propagation along
direction N1 to N2 through the LinkList from the seed links in L0.  
                
Note that the same link can appear multiple times in 
different stages because it might be activated first by itself 
(e.g. because its source is in Seed and its target is older than its source) 
and then by virtue of downstream propagation from some 
independently activated link upstream. 
                
If the graph ends up being cyclic, it prints an error message and
returns an empty recarray with the same fields as LinkList.
        
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:GetI}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.GetI \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetI}(\textit{List}, \textit{Seed})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:GetConnected}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.GetConnected \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GetConnected}(\textit{Seed}, \textit{level}={\tt -1}, \textit{Filter}={\tt True}, \textit{depends\_on}={\tt ('../',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Convenience function printing out targets at specified level away from seed in
link depedency network, for the LinkList loaded from live modules. 
        
ARGUMENTS:
--Seed = List of paths to propagate away from.          
--level = integer : level away from seed to find ; 
        -K means K leves upstream, +K means K levels downstream. 

RETURNS:
--Python set object containing paths of dependencies, if any.  
(If none a message is printed.)
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:LoadLiveModules}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.LoadLiveModules \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{LoadLiveModules}(\textit{LiveModuleFilters}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Makes a a list of live modules in the Data Environment filesystem, to 
    inspect for links.  Determined by reading contents from user specified 
    configuration file.  (see comments in body of the code)

    OVERALL: The strategy is going to be to get a list of regular 
    expression filters to apply a raw candidate list of directories; then 
    recursively list files in the directories that survive these filters; 
    and then return the .py files among this list.     The way that the 
    files are recursively searched can be done by user a user-specified 
    search function, a python function in a module whose python 'dot path' 
    is specified by setting the environment variable 
    'DotPathToLiveModuleFilterFunction.'  If this is not a specified a 
    default version is taken.

    First, getting the list of filters: Either it's given (whence it's not 
    None); or if it is None, then parse a user-specified configuration file
    that lists filters. The user-specified file's path is given by an 
    environment variable called 'LiveModuleFilterPath'. The format of the 
    filters is:  a pair (D,F) where D is a directory to search in, and F = 
    (r1,r2,....,NOT rn) is a list of regular expressions or regular 
    expressions preceeded by 'NOT ' The format of the user-specified file 
    is:  a list of lines, each of which species a (D,F) pair in the 
    following way:

    Path1 : r1, r2, NOT r3, r4, Path2 : r1, NOT r2 Path3

    Files from Path1 survive if the match any of the regular expressions 
    r1, r2, r4, ... but NONE of the expressions preceeded by a  'NOT ', 
    e.g. r3. If the line contains no ':' but only contains a directory 
    path, than the regular expression is assumed to be allow everything in 
    the directory.

    White space before and after the ':' in each line is ignored, as is 
    white space before and after each comma separating the regular 
    expression.

    For instance the follow is valid:

    ../Operations/: 
    {\textasciicircum}../Operations/[{\textasciicircum}/]*\$, 
    {\textasciicircum}../Operations/Dan\_Operations/* , NOT

    {\textasciicircum}../Operations/Dan\_Operations/ExamplesOfPCA*,NOT 
    {\textasciicircum}../Operations/Dan\_Operations/Dan\_SystemGraph*

    ../Users/DanYamins/

    ARGUMENTS: --An optional list of Filters can be passed to this 
    function, though it is uncommonly used.

    RETURNS: --A python list containing paths of python modules.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:FilterForAutomaticUpdates}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.FilterForAutomaticUpdates \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{FilterForAutomaticUpdates}(\textit{LList}, \textit{Exceptions}={\tt None}, \textit{AutomaticUpdateFilters}={\tt None}, \textit{ReturnIndices}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Filters a link links removing links that are not meant to be 
automatically updated when the system runs downstream 
updating -- except allows "exceptions" to pass. 
The strategy is to basically get the list of filters from a 
user-specified configuration file whoe path is given by the 
environment variable 'AutomaticUpdatesPath'.

ARGUMENTS:
--LList = LinkList as a numpy record array from which to filter. 
--Excetions = List of paths of scripts that should not be filtered out, regardless. 
--AutomaticUpdateFilters  : an optional list of filters can be passed in.  (but usually isn't)
--ReturnIndices:  boolean which if true means that the function will return 
the \_indices\_ in LinkList that are to be retained instead of the retained
links themselves. 
        
RETURNS:
If ReturnIndices = False:
        A subarray of LList if 
else:
        A numpy array of indices of LList. 
        
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:DownstreamFiles}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.DownstreamFiles \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{DownstreamFiles}(\textit{Sources}, \textit{depends\_on}={\tt ('../',)}, \textit{Filtering}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    A convenience function listing file downstream from a specified source 
    list in the LinkList dependencies in live modules.

    ARGUMENTS: --Sources:  list of sources to propagate downstream from. 
    --Filtering: boolean, which if set true retains only those targets that
    will be automatically updated.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:DownstreamAlongLinks}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.DownstreamAlongLinks \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{DownstreamAlongLinks}(\textit{Sources}, \textit{LinkList}, \textit{depends\_on}={\tt ('../',)})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:UpstreamFiles}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.UpstreamFiles \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{UpstreamFiles}(\textit{Targets}, \textit{depends\_on}={\tt ('../',)})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Analogous to DownstreamFiles.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:UpstreamAlongLinks}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.UpstreamAlongLinks \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{UpstreamAlongLinks}(\textit{Targets}, \textit{LinkList}, \textit{depends\_on}={\tt ('../',)})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{System:LinkManagement:UpstreamLinks}
    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}!System.LinkManagement.UpstreamLinks \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{UpstreamLinks}(\textit{Targets}, \textit{depends\_on}={\tt ('../',)})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright i\-s\-n\-a\-n\- & \raggedright \textbf{Value:} 
{\tt numpy.isnan}&\\
\cline{1-2}
\raggedright n\-a\-n\- & \raggedright \textbf{Value:} 
{\tt numpy.nan}&\\
\cline{1-2}
\raggedright D\-e\-f\-a\-u\-l\-t\-V\-a\-l\-u\-e\-F\-o\-r\-A\-u\-t\-o\-m\-a\-t\-i\-c\-U\-p\-d\-a\-t\-e\-s\- & \raggedright \textbf{Value:} 
{\tt ['{\textasciicircum}../(.*)']}&\\
\cline{1-2}
\raggedright D\-e\-f\-a\-u\-l\-t\-V\-a\-l\-u\-e\-F\-o\-r\-L\-i\-v\-e\-M\-o\-d\-u\-l\-e\-F\-i\-l\-t\-e\-r\-s\- & \raggedright \textbf{Value:} 
{\tt \{'../Operations/': ['../*']\}}&\\
\cline{1-2}
\end{longtable}

    \index{System \textit{(package)}!System.LinkManagement \textit{(module)}|)}
