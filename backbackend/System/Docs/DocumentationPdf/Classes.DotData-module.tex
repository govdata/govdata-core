%
% API Documentation for DataEnvironment
% Module Classes.DotData
%
% Generated by epydoc 3.0.1
% [Tue Mar 31 17:17:20 2009]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}|(}
\section{Module Classes.DotData}

    \label{Classes:DotData}
Classes and functions pertaining to the DotData class, a structured tabular
data object.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{Classes:DotData:AddOrReplaceColumns}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.AddOrReplaceColumns \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{AddOrReplaceColumns}(\textit{X}, \textit{Cols})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    technical dependency of .aggregate\_in method

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:GraySpec}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.GraySpec \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{GraySpec}(\textit{k})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    For integer argument k, returns list of k gray-scale colors, 
    increasingly light, linearly in the HSV color space, as web hex 
    triplets, . Technical dependency of .aggregate\_in method.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotDataAggregate}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotDataAggregate \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{DotDataAggregate}(\textit{X}, \textit{On}, \textit{AggFuncDict}={\tt None}, \textit{returnsort}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

used to aggregate a DotData on a set of specified factors, using
specified aggregation functions. 

ARGUMENTS:
-- X, DotData record array
-- On, list of column names in X
-- AggFuncDict -- dictionary where:
        -- keys are some (or all) column names of X that are NOT in 'On'  
        -- values are functions that can be applied to lists or numpy arrays
-- returnsort, boolean:  because the aggregation function sorts 
the original data, there's an argsort that can be returned.  If 
this boolean is true the return value is        [A,s] where A is the 
aggregated dotdata and s is the sorting permutation on the
original data set.  If false (the default) the return value is just A

Intuitively, this function will aggregate the dataset X on the 
columns listed in 'On', so that the resulting aggregate data set 
has one record for each unique tuples of values in those columns.   
The more factors listed in On argument, the "finer" is the 
aggregation, the fewer factors, the "coarser" the aggregation.    
For example, if On = ['A','B'], the resulting data set will have 
one record for each unique value of pairs (a,b) in X[['A','B']].   

The AggFuncDict argument specifies how to aggregate the factors
\_not\_ listed in 'On' -- the so-called "Off" columns. For example, if
On = ['A','B'] and 'C' is some other column, then AggFuncDict['C'] 
is the function that will be used to reduce to a single value
the (potentially multiple) values in the 'C' column 
corresponding to unique values in the 'A', 'B' columns.   
For instance, if
        AggFuncDict['C'] = numpy.mean
then the result will be that the values in the 'C' column 
corresponding to a single 'A','B' value will be averaged.  

If an "Off" column is \_not\_ provided as a key in AggFuncDict, 
a default aggregator function will be used:  the sum 
function for numerical columns, concatenation for string columns.    
        
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotDataFromPathList}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotDataFromPathList \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{DotDataFromPathList}(\textit{PathList})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Opens dotdatas from a list of dot-data paths, assuming they have 
    disjoint columns and identical numbers of rows; then stacks them 
    horizontally, e.g. adding columns side-by-side, aligning the rows.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:Pivot}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.Pivot \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{Pivot}(\textit{X}, \textit{a}, \textit{b}, \textit{Keep}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Implements pivoting on dotdatas.  
See http://en.wikipedia.org/wiki/Pivot\_table for information about pivot tables.

ARGUMENTS:
X -- dotdata 
a,b -- columns in X
Keep -- list of columns in X

RETURNS:
--X pivoted on (a,b) with a as the row axis and b values 
as the column axis. 

So-called "nontrivial columns relative to b" in X are added as
color-grouped sets of columns, and "trivial columns relative to b"  
are also retained as cross-grouped sets of columns if they're 
listed in 'Keep' argument.   

(A column 'c' in X is "trivial relative to b" if for all rows i, X[c][i]  
can be determined from X[b][i], e.g the elements in X[c] are in 
many-to-any correspondence with the values in X[b].)
        
The function will raise an exception if the list of pairs of values
in X[[a,b]] is not the product of the individual columns values, e.g. 
        X[[a,b]]   ==   set(X[a])   x   set(X[b])   ,
in some ordering. 
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:nullvalue}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.nullvalue \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{nullvalue}(\textit{test})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns a null value for each of various kinds of test values.

\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}|(}
\subsection{Class DotData}

    \label{Classes:DotData:DotData}
\begin{tabular}{cccccc}
% Line for Operations.DotDataFunctions.datahstack.numpy.core.records.recarray, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{Operations.DotDataFunctions.datahstack.numpy.core.records.recarray}\multirow{2}{\BCL}{Operations.DotDataFunctions.datahstack.numpy.core.records.recarray}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{Classes.DotData.DotData}}
\end{tabular}

A numpy recarray (a table with named columns where each column is of a 
uniform Python type), with added functionality and ability to define named 
groups of columns.

Invariants:

The names of all columns are distinct (unique) within one DotData.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{Classes:DotData:DotData:__new__}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.\_\_new\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_new\_\_}(\textit{subtype}, \textit{Array}={\tt None}, \textit{Records}={\tt None}, \textit{Columns}={\tt None}, \textit{shape}={\tt None}, \textit{dtype}={\tt None}, \textit{formats}={\tt None}, \textit{names}={\tt None}, \textit{ToLoad}={\tt None}, \textit{coloring}={\tt None}, \textit{Path}={\tt ''}, \textit{PathList}={\tt ''}, \textit{SVPath}={\tt ''}, \textit{SVDelimiter}={\tt None}, \textit{SVDelimiterRegExp}={\tt None}, \textit{SVLineBreak}={\tt None}, \textit{SVHeader}={\tt True}, \textit{SVHash}={\tt None}, \textit{SVLineFixer}={\tt None}, \textit{SVValueFixer}={\tt None}, \textit{Wrap}={\tt None}, \textit{SVSkipFirstLines}={\tt 0}, \textit{rowdata}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}
Construct a new DotData from a copy of the data that's passed in.   
     The new DotData is a separate object from all parts of the original data.

     There are several ways of creating a DotData.  You need to specify
     the table data, and the column headings.

     Specifying the data:

        - from a numpy.ndarray (Array arg)
        - from list of records (Records arg), where each record is represented
             as a sequence of elements
        - from list of columns (Columns arg), by passing each column as 
             list of uniform Python values.
        - from a .data directory (Path arg);
        - from an SV (separated-values) file (SVPath, SVDelimiter,
             SVDelimiterRegExp, SVLineBreak, SVHeader, SVHash, 
                     SVSkipFirstLines, SVLineFixer, SVValueFixer args)

     Specifying the column names:

       Column names can be inferred from the input data:
          - if you're constructing from a numpy.ndarray, the column names 
             are taken from its dtype attribute
          - if you're constructing from .data directory, the column names
             are taken from the names of .csv
          files in that directory.
          - if you're constructing from an SV file, the column names 
             can be taken from the headers in the file
          (by default they're assumed to be there).

       Or you can specify the column names as arguments:   

          - you can specify column names as the 'names' argument 
             (list of strings), or as the 'dtype' argument (numpy.dtype object).
        
       If you specify your own column names, and you're constructing from a numpy.recarray,
       they will override any column names from the numpy.recarray.
        
     You can specify a \_subset\_ of the columns to use, by specifying 
     the list of column names as the ToLoad argument.

     Specifying the colors (named column groups):

Colorings can be inferred from the input data:

       If constructing from a .data directory, colorings will be automaticallly
       inferred from the directory tree.

Colorings can be passed as argument:

       In the 'coloring' argument, pass a dictionary each color names
       (a string) to list of column names in that color.

If colorings are passed as argument, they override any colorings
inferred from the input data.

The Wrap argument adds a color with name Wrap (thus Wrap is a string) 
listing all column names.
(When this DotData is saved to a .data directory, all columns will be
nested in an additional directory, Wrap.data.)

     You can also specify some rowdata:
     
     The rowdata argument must either be None (no rowdata) or a record
     array the same length as the data set.     This rowdata is meant 
     to represent "row-by-row" metadata.   These are columns that
     you don't really want to appear in displays of the data set, but which 
     are meant to "travel with" no matter what subsetting you do on the 
     "real data" columns -- so that the rowdata columns will still be there 
     without your explicitly having to remember them.   

     One use of .rowdata columns is for formatting and communicating "side" 
     information to other DotData methods. For instance, various specially 
     designated columns in the .rowdata information can be used to tell other 
     applications that use DotDatas how to interpret the rows in a way that
     would be tedious for the user to have to remember to supply. Two instances of this are:
             
     -- A '\_\_color\_\_' column present in a DotData's rowdata is specially 
     interpreted by the browser's DotData- Html representation. The '\_\_color\_\_' column
     is expected in each row to contain a web-safe hex triplet color specification, 
     e.g a string of the form
             '\#XXXXXX' (see http://en.wikipedia.org/wiki/Web\_colors).  
     -- The 'Aggregates' columns is used to disambiguate rows that 
     are aggregates of data in other sets of rows for the .aggregate\_in method (see comments on that below). 
     
     Rowdata information can also be used to specify arbitrary higher-level 
     groups of rows, in analogy to how the "coloring" attribute 
     specifies groupings of columns.   This would work either by: 
             -- storing in a .rowdata column whose name specifies group name,
                     a boolean in each row as to whether the row belongs to that group, or
             -- for a "type" of grouping consisting of several nonintersecting row 
                     groups, a single column specifying by some string or integer code 
                     which group the row belongs to.  (An example of this is the "Aggregates"
                     column used by the .aggregate\_in method, see below for info about this.) 

     Parameters:

       subtype - the class object for the actual type of the newly created 
       DotData object.  (will be either type(DotData) or the type of a subclass).


        Arguments for recarray: shape, formats (see numpy docs)
        
     
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:extract}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.extract \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{extract}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Creates a copy of this DotData in the form of a numpy.ndarray.

    Useful if you want to do math on array elements, e.g. if you have a 
    subset of the columns that are all numerical, you can construct a 
    numerical matrix and do matrix operations.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:selectRowsUsingOneCriterion}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.selectRowsUsingOneCriterion \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{selectRowsUsingOneCriterion}(\textit{self}, \textit{expr})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return selected rows.

    If expr is a string or a code object, returns rows for which expr is 
    True.  Expr is either a string or a code object; if a string, it is 
    compiled into a code object.  The expression is evaluated for each row,
    in an environment in which column names are bound to column values in 
    that row. A DotData containing copies of rows for which the expression 
    evaluates to True is returned.

    If expr is a map of column names to values, returns rows for which the 
    specified columns have the specified values. Column names mapped to 
    None do not participate in the filtering.

    You can get the same effect by using self[expr], but the [] operator is
    getting very overloaded...

    See also: selectRows(), which can select rows according to a list of 
    criteria.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:selectRows}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.selectRows \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{selectRows}(\textit{self}, \textit{expr}, *\textit{exprs})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns a copy of rows matching all criteria in a list.  See 
    selectRowsAux() for documentation of the criteria.

    This method takes a variable number of arguments; each argument is a 
    separate criterion, and rows are returned which match ALL the criteria.

    See also: \_\_getitem\_\_().

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:__getitem__}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.\_\_getitem\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_getitem\_\_}(\textit{self}, \textit{attribute})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}
Returns a subrectangle of the table.

The representation of the subrectangle depends on type(attribute). Also,
whether the returned object represents a new independent copy of the
subrectangle, or a "view" into this self object, depends on type(attribute).

- if you pass the name of an existing coloring, you get a DotData consisting of
copies of columns in that coloring

- if you pass a list of existing coloring names and/or column names, you get a
DotData consisting of copies of columns in the list (name of coloring is
equivalent to list of names of columns in that coloring; duplicate columns are
deleted).

- if you pass a Python expression as a code object (see compile\_expr()), where
columns names are used in the expression as variables, you get subset of rows
for which the expression is true; more specifically, you get a DotData consisting
of copies of rows for which the expression evaluates to True, in an environment
where column names are bound to the corresponding values for each row.

- if you pass a dictionary mapping column names to values, you get back rows
where the specified columns have the specified values (more specifically, you
get a new DotData containing copies of these rows). Dictionary entries mapping
to None are ignored.

- if you pass an ndarray, you get a DotData consisting a subrectangle of the
table, as handled by recarray's: * if you pass a 1D ndarray of booleans of
len(DotData), the rectangle contains copies of the rows for which the
corresponding entry is True. * if you pass a list of row numbers, you get a
DotData containing copies of these rows.


See also: selectRows(), which lets you specify several row-selection criteria at
once, and lets you pass an expression for selecting the rows as a string rather
than only as a Python code object.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:__getslice__}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.\_\_getslice\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_getslice\_\_}(\textit{self}, \textit{attribute1}, \textit{attribute2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns a slice into the array: a \_contiguous\_ range of its rows. 
    This is not a copy but a mutable reference into the array.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:vstack}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.vstack \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{vstack}(\textit{self}, \textit{new})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Create a new DotData that has rows of self followed by rows of new, 
    with the headers, colorings and rowdata correctly merged.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:hstack}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.hstack \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{hstack}(\textit{self}, \textit{new})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Create a new DotData that has columns of self followed by columns of 
    new, with the headers and colorings correctly merged.  rowdata is 
    merged by simple SafeColumnStack (if there's repeated column names from
    different arrays, no exception is raised and the data from the first 
    array that has that rowdata is taken)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:addrecords}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.addrecords \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{addrecords}(\textit{self}, \textit{new})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Append one or more records to the end of the array. Can take a single 
    record or tuple, or a list of records/tuples.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:copy}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.copy \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{copy}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:recordsAsDicts}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.recordsAsDicts \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{recordsAsDicts}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return an interator over the records, which yields each record as a 
    dictionary mapping column name to the value of that column in that 
    record.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:view}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.view \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{view}(\textit{self}, \textit{obj}={\tt numpy.core.records.recarray})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:save}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.save \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{save}(\textit{self}, \textit{TargetFolderName}, \textit{HeaderOn}={\tt 1})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Save the DotData to a folder, preserving the colorings.  Can later be 
    loaded back by passing the folder as the Path argument to DotData 
    constructor.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:AppendToFile}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.AppendToFile \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{AppendToFile}(\textit{self}, \textit{Target})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Like "save" but for appending instead of writing from scratch.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:ColIdx}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.ColIdx \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{ColIdx}(\textit{self}, \textit{colName})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return the index of the column with the given name

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:mergeOnKeyCols}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.mergeOnKeyCols \textit{(static method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{mergeOnKeyCols}(\textit{dotDatas}, \textit{primaryKeyCols}, \textit{blanks}, \textit{suffixes}, \textit{verbose}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Merge several dotDatas based on primary key columns.

    Parameters:

    dotDatas - sequence of DotDatas to join primaryKeyCols - sequence of 
    column names, one for each DotData in dotDatas. these columns should 
    all have the same type of data, typically an identifier telling us for 
    what entity (e.g. for what SNP) that row gives information.

    If each item in the sequence is a tuple of column names rather than a 
    single column name, then the primary key from the corresponding DotData
    is the tuple of values from these columns, rather than a single value 
    from one column.

    blanks - when a DotData does not have a value for a given primary key, 
    this tuple is filled in. suffixes - sequence of suffixes, one for each 
    DotData, to append to names of columns from that DotData to make them 
    unique, if needed.

    For each primary key value existing in at least one DotData, we create 
    one output record in the resulting merged DotData; these records are in
    order of primary key.   The columns in the output are obtained by 
    concatenating column name lists of the input DotDatas; any column names
    shared between two or more dotDatas are made unique by appending the 
    corresponding suffix from 'suffixes'.   The record corresponding to a 
    given primary key is obtained by concatenating the records of the input
    dotDatas; when some input dotData does not have a row with the given 
    primary key, the corresponding tuple from 'blanks' is used instead.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:numCols}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.numCols \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{numCols}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return the number of columns in this DotData

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:numRows}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.numRows \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{numRows}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return the number of rows in this DotData

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:saveToSV}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.saveToSV \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{saveToSV}(\textit{self}, \textit{TargetFileName}, \textit{sep}={\tt None}, \textit{linesep}={\tt '{\textbackslash}n'}, \textit{UseHeader}={\tt True})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Save the DotData to a single flat file.  Column headers are kept, but 
    colorings are lost.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:saveColumns}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.saveColumns \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{saveColumns}(\textit{self}, \textit{TargetFolderName})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Save the DotData to a set of flat .csv files in .data format (i.e. 
    .int.csv, .float.csv, .str.csv). Colorings are lost.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:isPrimaryKey}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.isPrimaryKey \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{isPrimaryKey}(\textit{self}, \textit{columnName})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Test whether the given column is a primary key, i.e. that each row has 
    a unique value in this column, different from the value in any other 
    row.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:aggregate}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.aggregate \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{aggregate}(\textit{self}, \textit{On}, \textit{AggFuncDict}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Aggregate a dataset, on specifed columns, using specified aggregation 
    functions.  See commends for DotDataAggregate function.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:pivot}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.pivot \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{pivot}(\textit{self}, \textit{a}, \textit{b}, \textit{Keep}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Pivot a DotData table  on columns a,b. See comments for Pivot function,
    and http://en.wikipedia.org/wiki/Pivot\_table.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Classes:DotData:DotData:aggregate_in}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}!Classes.DotData.DotData.aggregate\_in \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{aggregate\_in}(\textit{self}, \textit{On}, \textit{AggFuncDict}={\tt None}, \textit{interspersed}={\tt True})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Take aggregate of data set on specified columns, then add the 
resulting rows back into data set to make a composite object 
containing both original non-aggregate data rows as well as the 
aggregate rows. 

First read commends for aggregate method.  Now:
ARGUMENTS:
--On, AggFuncDict -- same as arguments for aggregate method. 
-- interspersed : boolean, if true aggregate rows are interleaved 
with the data of which they are aggregates, if false, all aggregate 
rows placed at the end of the array. 

RETURNS:
A DotData, with number of rows equaling:
                len(self) + len(A)
where A is the the result of self.aggregate(On,AggFuncDict).
A represents the aggregate rows and the other 
rows were the original data rows. 
                
This function supports \_multiple\_ aggregation, meaning that one
can first aggregate on one set of factors, then repeat
aggregation on the result for another set of factors, without the
results of the first aggregation interfering the second.  To achieve 
this, the method adds (or augments, if already present), some
.rowdata information.  (See comments on \_\_new\_\_ of DotData 
for more about rowdata information in general).     
The specific rowdata information added by the aggregate\_in 
method is a column called "Aggregates" specifying on which 
factors the rows that are aggregate rows were aggregated.  
Rows added by aggregating on factor 'A' (a column in the original 
data set) will have 'A' in the 'Aggregates' column of the self.rowdata array.  
When multiple factors 'A1', 'A2' , ... are aggregated on, the notation
is a comma-separated list 'A1,A2,...'.    This way, when you call
.aggregate\_in again, the function only aggregates on the columns 
that have the empty char '' in their "Aggregates" rowdata.   

The function also adds (or adds rows to) a '\_\_color\_\_' column 
to self.rowdata, specifying Gray-Scale colors for aggregated
rows that will be used by the Data Environment system's 
browser for colorizing the  data.   When there are multiple
levels of aggregation, the coarser aggregate groups 
(e.g. on fewer factors) get darker gray color then those on
finer aggregate groups (e.g. more factors).  
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}!Classes.DotData.DotData \textit{(class)}|)}
    \index{Classes \textit{(package)}!Classes.DotData \textit{(module)}|)}
